scalar Cursor
scalar Time
scalar Upload

"Used to provide a human-friendly description of an access scope"
directive @scopehelp(details: String!) on ENUM_VALUE

"""
This is used to decorate fields which are only accessible with a personal
access token, and are not available to clients using OAuth 2.0 access tokens.
"""
directive @private on FIELD_DEFINITION

"""
This is used to decorate fields which are for internal use, and are not
available to normal API users.
"""
directive @internal on FIELD_DEFINITION

enum AccessScope {
  PROFILE @scopehelp(details: "profile information")
  SITES   @scopehelp(details: "registered sites")
  PAGES   @scopehelp(details: "contents of registered sites")
}

enum AccessKind {
  RO @scopehelp(details: "read")
  RW @scopehelp(details: "read and write")
}

"""
Decorates fields for which access requires a particular OAuth 0.0 scope with
read or write access.
"""
directive @access(scope: AccessScope!, kind: AccessKind!) on FIELD_DEFINITION

enum Protocol {
  HTTPS
  GEMINI
}

# https://semver.org
type Version {
  major: Int!
  minor: Int!
  patch: Int!
  """
  If this API version is scheduled for deprecation, this is the date on which
  it will stop working; or null if this API version is not scheduled for
  deprecation.
  """
  deprecationDate: Time
}

interface Entity {
  id: Int!
  created: Time!
  updated: Time!
  """
  The canonical name of this entity. For users, this is their username
  prefixed with '~'. Additional entity types will be supported in the future.
  """
  canonicalName: String!
}

type User implements Entity {
  id: Int!
  created: Time!
  updated: Time!
  canonicalName: String!
  username: String!
  email: String!
  url: String
  location: String
  bio: String
}

"A published website"
type Site {
  id: Int!
  created: Time!
  updated: Time!
  "Domain name the site services"
  domain: String!
  "The site protocol"
  protocol: Protocol!
  "SHA-256 checksum of the source tarball (uncompressed)"
  version: String!
  "Path to the file to serve for 404 Not Found responses"
  notFound: String
}

"""
A cursor for enumerating site entries

If there are additional results available, the cursor object may be passed
back into the same endpoint to retrieve another page. If the cursor is null,
there are no remaining results to return.
"""
type SiteCursor {
  results: [Site!]!
  cursor: Cursor
}

"""
Options for a file being served.
"""
input FileOptions {
  "Value of the Cache-Control header to be used when serving the file."
  cacheControl: String
}

"""
Provides a way to configure options for a set of files matching the glob
pattern.
"""
input FileConfig {
  glob: String!
  options: FileOptions!
}

input SiteConfig {
  "Path to the file to serve for 404 Not Found responses"
  notFound: String
  fileConfigs: [FileConfig!]
}

type OAuthClient {
  uuid: String!
}

enum WebhookEvent {
  SITE_PUBLISHED
  SITE_UNPUBLISHED
}

interface WebhookSubscription {
  id: Int!
  events: [WebhookEvent!]!
  query: String!
  url: String!

  """
  If this webhook was registered by an authorized OAuth 2.0 client, this
  field is non-null.
  """
  client: OAuthClient @private

  "All deliveries which have been sent to this webhook."
  deliveries(cursor: Cursor): WebhookDeliveryCursor!

  "Returns a sample payload for this subscription, for testing purposes"
  sample(event: WebhookEvent!): String!
}

type UserWebhookSubscription implements WebhookSubscription {
  id: Int!
  events: [WebhookEvent!]!
  query: String!
  url: String!
  client: OAuthClient @private
  deliveries(cursor: Cursor): WebhookDeliveryCursor!
  sample(event: WebhookEvent!): String!
}

type WebhookDelivery {
  uuid: String!
  date: Time!
  event: WebhookEvent!
  subscription: WebhookSubscription!
  requestBody: String!

  """
  These details are provided only after a response is received from the
  remote server. If a response is sent whose Content-Type is not text/*, or
  cannot be decoded as UTF-8, the response body will be null. It will be
  truncated after 64 KiB.
  """
  responseBody: String
  responseHeaders: String
  responseStatus: Int
}

interface WebhookPayload {
  uuid: String!
  event: WebhookEvent!
  date: Time!
}

type SiteEvent implements WebhookPayload {
  uuid: String!
  event: WebhookEvent!
  date: Time!

  site: Site!
}

"""
A cursor for enumerating a list of webhook deliveries

If there are additional results available, the cursor object may be passed
back into the same endpoint to retrieve another page. If the cursor is null,
there are no remaining results to return.
"""
type WebhookDeliveryCursor {
  results: [WebhookDelivery!]!
  cursor: Cursor
}

"""
A cursor for enumerating a list of webhook subscriptions

If there are additional results available, the cursor object may be passed
back into the same endpoint to retrieve another page. If the cursor is null,
there are no remaining results to return.
"""
type WebhookSubscriptionCursor {
  results: [WebhookSubscription!]!
  cursor: Cursor
}

type Query {
  "Returns API version information."
  version: Version!

  "Returns the authenticated user."
  me: User! @access(scope: PROFILE, kind: RO)

  "Returns a list of registered sites on your account."
  sites(cursor: Cursor): SiteCursor! @access(scope: SITES, kind: RO)

  """
  Returns a list of user webhook subscriptions. For clients
  authenticated with a personal access token, this returns all webhooks
  configured by all GraphQL clients for your account. For clients
  authenticated with an OAuth 2.0 access token, this returns only webhooks
  registered for your client.
  """
  userWebhooks(cursor: Cursor): WebhookSubscriptionCursor!

  "Returns details of a user webhook subscription by its ID."
  userWebhook(id: Int!): WebhookSubscription

  """
  Returns information about the webhook currently being processed. This is
  not valid during normal queries over HTTP, and will return an error if used
  outside of a webhook context.
  """
  webhook: WebhookPayload!
}

input UserWebhookInput {
  url: String!
  events: [WebhookEvent!]!
  query: String!
}

type Mutation {
  """
  Publishes a website. If the domain already exists on your account, it is
  updated to a new version. If the domain already exists under someone else's
  account, the request is rejected. If the domain does not exist, a new site
  is created.

  Every user is given exclusive use over the 'username.srht.site' domain, and
  it requires no special configuration to use. Users may also bring their own
  domain name, in which case they should consult the configuration docs:

  https://man.sr.ht/pages.sr.ht

  'content' must be a .tar.gz file. It must contain only directories and
  regular files of mode 644. Symlinks are not supported. No error is returned
  for an invalid tarball; the invalid data is simply discarded.

  If protocol is unset, HTTPS is presumed.

  If subdirectory is set, only the specified directory is updated. The rest
  of the files are unchanged.
  """
  publish(domain: String!, content: Upload!, protocol: Protocol,
    subdirectory: String, siteConfig: SiteConfig): Site! @access(scope: PAGES, kind: RW)

  """
  Deletes a previously published website.

  If protocol is unset, HTTPS is presumed.
  """
  unpublish(domain: String!, protocol: Protocol): Site @access(scope: SITES, kind: RW)

  """
  Creates a new user webhook subscription. When an event from the
  provided list of events occurs, the 'query' parameter (a GraphQL query)
  will be evaluated and the results will be sent to the provided URL as the
  body of an HTTP POST request. The list of events must include at least one
  event, and no duplicates.

  This query is evaluated in the webhook context, such that query { webhook }
  may be used to access details of the event which trigged the webhook. The
  query may not make any mutations.
  """
  createUserWebhook(config: UserWebhookInput!): WebhookSubscription!

  """
  Deletes a user webhook. Any events already queued may still be
  delivered after this request completes. Clients authenticated with a
  personal access token may delete any webhook registered for their account,
  but authorized OAuth 2.0 clients may only delete their own webhooks.
  Manually deleting a webhook configured by a third-party client may cause
  unexpected behavior with the third-party integration.
  """
  deleteUserWebhook(id: Int!): WebhookSubscription!

  """
  Deletes the authenticated user's account. Internal use only.
  """
  deleteUser: Int! @internal
}
