// Code generated by gqlclientgen - DO NOT EDIT.

package metasrht

import (
	"context"
	"encoding/json"
	"fmt"
	gqlclient "git.sr.ht/~emersion/gqlclient"
)

type AccessKind string

const (
	AccessKindRo AccessKind = "RO"
	AccessKindRw AccessKind = "RW"
)

type AccessScope string

const (
	AccessScopeAuditLog AccessScope = "AUDIT_LOG"
	AccessScopeBilling  AccessScope = "BILLING"
	AccessScopePgpKeys  AccessScope = "PGP_KEYS"
	AccessScopeSshKeys  AccessScope = "SSH_KEYS"
	AccessScopeProfile  AccessScope = "PROFILE"
)

// A cursor for enumerating a list of audit log entries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type AuditLogCursor struct {
	Results []AuditLogEntry `json:"results"`
	Cursor  *Cursor         `json:"cursor,omitempty"`
}

type AuditLogEntry struct {
	Id        int32          `json:"id"`
	Created   gqlclient.Time `json:"created"`
	IpAddress string         `json:"ipAddress"`
	EventType string         `json:"eventType"`
	Details   *string        `json:"details,omitempty"`
}

// Billing address for invoicing.
type BillingAddress struct {
	FullName     *string `json:"fullName,omitempty"`
	BusinessName *string `json:"businessName,omitempty"`
	Address1     *string `json:"address1,omitempty"`
	Address2     *string `json:"address2,omitempty"`
	City         *string `json:"city,omitempty"`
	Region       *string `json:"region,omitempty"`
	Postcode     *string `json:"postcode,omitempty"`
	// ISO 3166 two-letter country code
	Country *string `json:"country,omitempty"`
	// Value-added tax number (EU)
	Vat *string `json:"vat,omitempty"`
}

// All fields are optional. If a field is omitted, it is unchanged. If a field is
// null, it is set to null.
type BillingAddressInput struct {
	FullName     *string `json:"fullName,omitempty"`
	BusinessName *string `json:"businessName,omitempty"`
	Address1     *string `json:"address1,omitempty"`
	Address2     *string `json:"address2,omitempty"`
	City         *string `json:"city,omitempty"`
	Region       *string `json:"region,omitempty"`
	Postcode     *string `json:"postcode,omitempty"`
	// ISO 3166 two-letter country code
	Country *string `json:"country,omitempty"`
	// Value-added tax number (EU)
	Vat *string `json:"vat,omitempty"`
}

type BillingSubscription struct {
	Id      int32              `json:"id"`
	User    *User              `json:"user"`
	Created gqlclient.Time     `json:"created"`
	Updated gqlclient.Time     `json:"updated"`
	Status  SubscriptionStatus `json:"status"`
	// If true, payment is automatically renewed when term ellapses.
	Autorenew bool            `json:"autorenew"`
	Currency  Currency        `json:"currency"`
	Interval  PaymentInterval `json:"interval"`
	// Selected product associated with this subscription.
	Product *Product `json:"product"`
	// Shortcut to get the applicable price point for this subscription's product ID
	// and applicable currency
	Price *ProductPrice `json:"price"`
	// Total price, not including applicable taxes, in the smallest denomination of
	// the currency, e.g. cents USD.
	Subtotal int32 `json:"subtotal"`
	// Status of the last attempted payment for this subscription.
	Payment *PaymentOutcome `json:"payment"`
}

type Currency string

const (
	CurrencyEur Currency = "EUR"
	CurrencyUsd Currency = "USD"
)

type Cursor string

type Entity struct {
	Id      int32          `json:"id"`
	Created gqlclient.Time `json:"created"`
	Updated gqlclient.Time `json:"updated"`
	// The canonical name of this entity. For users, this is their username
	// prefixed with '~'. Additional entity types will be supported in the future.
	CanonicalName string `json:"canonicalName"`

	// Underlying value of the GraphQL interface
	Value EntityValue `json:"-"`
}

func (base *Entity) UnmarshalJSON(b []byte) error {
	type Raw Entity
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "User":
		base.Value = new(User)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface Entity: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// EntityValue is one of: User
type EntityValue interface {
	isEntity()
}

type Invoice struct {
	Id        int32          `json:"id"`
	InvoiceNo string         `json:"invoiceNo"`
	Issued    gqlclient.Time `json:"issued"`
	Entity    *Entity        `json:"entity"`
	Product   *Product       `json:"product"`
	// Start of service period for which this invoice applies
	ServiceStart gqlclient.Time `json:"serviceStart"`
	// End of service period for which this invoice applies
	ServiceEnd gqlclient.Time `json:"serviceEnd"`
	Currency   Currency       `json:"currency"`
	// Amount charged denoted in the smallest denomination of the applicable
	// currency, e.g. cents USD.
	Total int32 `json:"total"`
}

// A cursor for enumerating a list of invoices
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type InvoiceCursor struct {
	Results []Invoice `json:"results"`
	Cursor  *Cursor   `json:"cursor,omitempty"`
}

type OAuthClient struct {
	Id          int32   `json:"id"`
	Uuid        string  `json:"uuid"`
	RedirectUrl string  `json:"redirectUrl"`
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	Url         *string `json:"url,omitempty"`
	Owner       *Entity `json:"owner"`
}

type OAuthClientRegistration struct {
	Client *OAuthClient `json:"client"`
	Secret string       `json:"secret"`
}

type OAuthGrant struct {
	Id        int32          `json:"id"`
	Client    *OAuthClient   `json:"client"`
	Issued    gqlclient.Time `json:"issued"`
	Expires   gqlclient.Time `json:"expires"`
	TokenHash string         `json:"tokenHash"`
	Grants    *string        `json:"grants,omitempty"`
}

type OAuthGrantRegistration struct {
	Grant        *OAuthGrant `json:"grant"`
	Grants       string      `json:"grants"`
	Secret       string      `json:"secret"`
	RefreshToken string      `json:"refreshToken"`
}

type OAuthPersonalToken struct {
	Id      int32          `json:"id"`
	Issued  gqlclient.Time `json:"issued"`
	Expires gqlclient.Time `json:"expires"`
	Comment *string        `json:"comment,omitempty"`
	Grants  *string        `json:"grants,omitempty"`
}

type OAuthPersonalTokenRegistration struct {
	Token  *OAuthPersonalToken `json:"token"`
	Secret string              `json:"secret"`
}

type PGPKey struct {
	Id          int32          `json:"id"`
	Created     gqlclient.Time `json:"created"`
	User        *User          `json:"user"`
	Key         string         `json:"key"`
	Fingerprint string         `json:"fingerprint"`
}

// A cursor for enumerating a list of PGP keys
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type PGPKeyCursor struct {
	Results []PGPKey `json:"results"`
	Cursor  *Cursor  `json:"cursor,omitempty"`
}

type PGPKeyEvent struct {
	Uuid  string         `json:"uuid"`
	Event WebhookEvent   `json:"event"`
	Date  gqlclient.Time `json:"date"`
	Key   *PGPKey        `json:"key"`
}

func (*PGPKeyEvent) isWebhookPayload() {}

type PaymentIntent struct {
	Id             string               `json:"id"`
	Subscription   *BillingSubscription `json:"subscription"`
	BillingAddress *BillingAddress      `json:"billingAddress"`
	IdempotencyKey string               `json:"idempotencyKey"`
	TaxRate        *int32               `json:"taxRate,omitempty"`
	TaxDue         int32                `json:"taxDue"`
	TotalDue       int32                `json:"totalDue"`
	Method         *PaymentMethod       `json:"method,omitempty"`
	Outcome        *PaymentOutcome      `json:"outcome,omitempty"`

	// Underlying value of the GraphQL interface
	Value PaymentIntentValue `json:"-"`
}

func (base *PaymentIntent) UnmarshalJSON(b []byte) error {
	type Raw PaymentIntent
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "StripePaymentIntent":
		base.Value = new(StripePaymentIntent)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface PaymentIntent: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// PaymentIntentValue is one of: StripePaymentIntent
type PaymentIntentValue interface {
	isPaymentIntent()
}

type PaymentIntentStatus string

const (
	PaymentIntentStatusPending    PaymentIntentStatus = "PENDING"
	PaymentIntentStatusCancelled  PaymentIntentStatus = "CANCELLED"
	PaymentIntentStatusProcessing PaymentIntentStatus = "PROCESSING"
	PaymentIntentStatusFailed     PaymentIntentStatus = "FAILED"
	PaymentIntentStatusSucceeded  PaymentIntentStatus = "SUCCEEDED"
)

type PaymentInterval string

const (
	PaymentIntervalMonthly  PaymentInterval = "MONTHLY"
	PaymentIntervalAnnually PaymentInterval = "ANNUALLY"
)

type PaymentMethod struct {
	Id      int32          `json:"id"`
	Created gqlclient.Time `json:"created"`
	// User-friendly name of this payment method (e.g. 'Visa ending in 1234')
	Name string `json:"name"`
	// Expiration date of this payment method, if applicable to the type
	Expires gqlclient.Time `json:"expires,omitempty"`
}

type PaymentOutcome struct {
	Status PaymentIntentStatus `json:"status"`
	Error  *string             `json:"error,omitempty"`
}

type PaymentStatus string

const (
	// User does not pay for their account
	PaymentStatusUnpaid PaymentStatus = "UNPAID"
	// User is paid and their payment is current
	PaymentStatusCurrent PaymentStatus = "CURRENT"
	// User's payment has lapsed
	PaymentStatusDelinquent PaymentStatus = "DELINQUENT"
	// User's paid services are subsidized
	PaymentStatusSubsidized PaymentStatus = "SUBSIDIZED"
	// User receives paid services for free
	PaymentStatusFree PaymentStatus = "FREE"
)

// A paid product available for purchase.
type Product struct {
	Id      int32          `json:"id"`
	Name    string         `json:"name"`
	Prices  []ProductPrice `json:"prices"`
	Retired bool           `json:"retired"`
}

// Price point for a product in a given currency.
type ProductPrice struct {
	// Applicable currency for this price
	Currency Currency `json:"currency"`
	// Price in the smallest denomination of the currency, e.g. cents USD. Does not
	// include any applicable taxes.
	Amount int32 `json:"amount"`
}

type ProductPriceInput struct {
	Currency Currency `json:"currency"`
	Amount   int32    `json:"amount"`
}

type ProfileUpdateEvent struct {
	Uuid    string         `json:"uuid"`
	Event   WebhookEvent   `json:"event"`
	Date    gqlclient.Time `json:"date"`
	Profile *User          `json:"profile"`
}

func (*ProfileUpdateEvent) isWebhookPayload() {}

type ProfileWebhookInput struct {
	Url    string         `json:"url"`
	Events []WebhookEvent `json:"events"`
	Query  string         `json:"query"`
}

type ProfileWebhookSubscription struct {
	Id         int32                  `json:"id"`
	Events     []WebhookEvent         `json:"events"`
	Query      string                 `json:"query"`
	Url        string                 `json:"url"`
	Client     *OAuthClient           `json:"client,omitempty"`
	Deliveries *WebhookDeliveryCursor `json:"deliveries"`
	Sample     string                 `json:"sample"`
}

func (*ProfileWebhookSubscription) isWebhookSubscription() {}

type SSHKey struct {
	Id          int32          `json:"id"`
	Created     gqlclient.Time `json:"created"`
	LastUsed    gqlclient.Time `json:"lastUsed,omitempty"`
	User        *User          `json:"user"`
	Key         string         `json:"key"`
	Fingerprint string         `json:"fingerprint"`
	Comment     *string        `json:"comment,omitempty"`
	Username    string         `json:"username"`
}

// A cursor for enumerating a list of SSH keys
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type SSHKeyCursor struct {
	Results []SSHKey `json:"results"`
	Cursor  *Cursor  `json:"cursor,omitempty"`
}

type SSHKeyEvent struct {
	Uuid  string         `json:"uuid"`
	Event WebhookEvent   `json:"event"`
	Date  gqlclient.Time `json:"date"`
	Key   *SSHKey        `json:"key"`
}

func (*SSHKeyEvent) isWebhookPayload() {}

type SetupIntent struct {
	Id     string         `json:"id"`
	Method *PaymentMethod `json:"method,omitempty"`

	// Underlying value of the GraphQL interface
	Value SetupIntentValue `json:"-"`
}

func (base *SetupIntent) UnmarshalJSON(b []byte) error {
	type Raw SetupIntent
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "StripeSetupIntent":
		base.Value = new(StripeSetupIntent)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface SetupIntent: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// SetupIntentValue is one of: StripeSetupIntent
type SetupIntentValue interface {
	isSetupIntent()
}

type StripePaymentIntent struct {
	Id             string               `json:"id"`
	Subscription   *BillingSubscription `json:"subscription"`
	BillingAddress *BillingAddress      `json:"billingAddress"`
	IdempotencyKey string               `json:"idempotencyKey"`
	TotalDue       int32                `json:"totalDue"`
	TaxRate        *int32               `json:"taxRate,omitempty"`
	TaxDue         int32                `json:"taxDue"`
	Method         *PaymentMethod       `json:"method,omitempty"`
	Outcome        *PaymentOutcome      `json:"outcome,omitempty"`
	ClientSecret   *string              `json:"clientSecret,omitempty"`
}

func (*StripePaymentIntent) isPaymentIntent() {}

type StripeSetupIntent struct {
	Id           string         `json:"id"`
	Method       *PaymentMethod `json:"method,omitempty"`
	ClientSecret *string        `json:"clientSecret,omitempty"`
}

func (*StripeSetupIntent) isSetupIntent() {}

type SubscriptionStatus string

const (
	// This subscription is pending and will become active once the first payment is
	// successfully recieved.
	SubscriptionStatusPending SubscriptionStatus = "PENDING"
	// This subscription is paid but the payment has not settled. Paid services are
	// available while awaiting settlement.
	SubscriptionStatusSettlement SubscriptionStatus = "SETTLEMENT"
	// This is the user's active subscription.
	SubscriptionStatusActive SubscriptionStatus = "ACTIVE"
	// This subscription has been cancelled and the service term is complete.
	SubscriptionStatusInactive SubscriptionStatus = "INACTIVE"
)

// For changing the active paid subscription's parameters. Changes apply from the
// start of the next payment term (i.e. from User.paymentDue).
type UpdateBillingSubscriptionInput struct {
	ProductID int32           `json:"productID"`
	Interval  PaymentInterval `json:"interval"`
}

type User struct {
	Id            int32          `json:"id"`
	Created       gqlclient.Time `json:"created"`
	Updated       gqlclient.Time `json:"updated"`
	CanonicalName string         `json:"canonicalName"`
	Username      string         `json:"username"`
	Email         string         `json:"email"`
	Url           *string        `json:"url,omitempty"`
	Location      *string        `json:"location,omitempty"`
	Bio           *string        `json:"bio,omitempty"`
	SshKeys       *SSHKeyCursor  `json:"sshKeys"`
	PgpKeys       *PGPKeyCursor  `json:"pgpKeys"`
	// User's current payment status. Only available if authenticated as this user.
	PaymentStatus PaymentStatus `json:"paymentStatus"`
	// Date at which next payment is due. Only available if authenticated as this
	// user.
	PaymentDue gqlclient.Time `json:"paymentDue,omitempty"`
	// Details about the user's current paid subscription. Only available if
	// authenticated as this user.
	Subscription *BillingSubscription `json:"subscription,omitempty"`
	// Returns invoices for this user. Only available if authenticated as this user.
	Invoices *InvoiceCursor `json:"invoices"`
	// User's billing address, if applicable, for invoicing.
	BillingAddress *BillingAddress `json:"billingAddress,omitempty"`
	// User's payment methods, if any.
	PaymentMethods []PaymentMethod `json:"paymentMethods"`
	// The default payment method in use for automatic subscription renewals.
	DefaultPaymentMethod *PaymentMethod `json:"defaultPaymentMethod,omitempty"`
	// Internal user type (e.g. is admin)
	UserType UserType `json:"userType"`
	// Returns true if this user should have access to paid services.
	ReceivesPaidServices bool `json:"receivesPaidServices"`
	// Notice to provide to a suspended account
	SuspensionNotice *string `json:"suspensionNotice,omitempty"`
}

func (*User) isEntity() {}

// Omit these fields to leave them unchanged, or set them to null to clear
// their value.
type UserInput struct {
	Url      *string `json:"url,omitempty"`
	Location *string `json:"location,omitempty"`
	Bio      *string `json:"bio,omitempty"`
	// Note: changing the user's email address will not take effect immediately;
	// the user is sent an email to confirm the change first.
	Email *string `json:"email,omitempty"`
}

type UserType string

const (
	UserTypePending   UserType = "PENDING"
	UserTypeUser      UserType = "USER"
	UserTypeAdmin     UserType = "ADMIN"
	UserTypeSuspended UserType = "SUSPENDED"
)

type Version struct {
	Major int32 `json:"major"`
	Minor int32 `json:"minor"`
	Patch int32 `json:"patch"`
	// If this API version is scheduled for deprecation, this is the date on which
	// it will stop working; or null if this API version is not scheduled for
	// deprecation.
	DeprecationDate gqlclient.Time `json:"deprecationDate,omitempty"`
}

type WebhookDelivery struct {
	Uuid         string               `json:"uuid"`
	Date         gqlclient.Time       `json:"date"`
	Event        WebhookEvent         `json:"event"`
	Subscription *WebhookSubscription `json:"subscription"`
	RequestBody  string               `json:"requestBody"`
	// These details are provided only after a response is received from the
	// remote server. If a response is sent whose Content-Type is not text/*, or
	// cannot be decoded as UTF-8, the response body will be null. It will be
	// truncated after 64 KiB.
	ResponseBody    *string `json:"responseBody,omitempty"`
	ResponseHeaders *string `json:"responseHeaders,omitempty"`
	ResponseStatus  *int32  `json:"responseStatus,omitempty"`
}

// A cursor for enumerating a list of webhook deliveries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type WebhookDeliveryCursor struct {
	Results []WebhookDelivery `json:"results"`
	Cursor  *Cursor           `json:"cursor,omitempty"`
}

type WebhookEvent string

const (
	// Used for user profile webhooks
	WebhookEventProfileUpdate WebhookEvent = "PROFILE_UPDATE"
	WebhookEventPgpKeyAdded   WebhookEvent = "PGP_KEY_ADDED"
	WebhookEventPgpKeyRemoved WebhookEvent = "PGP_KEY_REMOVED"
	WebhookEventSshKeyAdded   WebhookEvent = "SSH_KEY_ADDED"
	WebhookEventSshKeyRemoved WebhookEvent = "SSH_KEY_REMOVED"
)

type WebhookPayload struct {
	Uuid  string         `json:"uuid"`
	Event WebhookEvent   `json:"event"`
	Date  gqlclient.Time `json:"date"`

	// Underlying value of the GraphQL interface
	Value WebhookPayloadValue `json:"-"`
}

func (base *WebhookPayload) UnmarshalJSON(b []byte) error {
	type Raw WebhookPayload
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "ProfileUpdateEvent":
		base.Value = new(ProfileUpdateEvent)
	case "PGPKeyEvent":
		base.Value = new(PGPKeyEvent)
	case "SSHKeyEvent":
		base.Value = new(SSHKeyEvent)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface WebhookPayload: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// WebhookPayloadValue is one of: ProfileUpdateEvent | PGPKeyEvent | SSHKeyEvent
type WebhookPayloadValue interface {
	isWebhookPayload()
}

type WebhookSubscription struct {
	Id     int32          `json:"id"`
	Events []WebhookEvent `json:"events"`
	Query  string         `json:"query"`
	Url    string         `json:"url"`
	// If this webhook was registered by an authorized OAuth 2.0 client, this
	// field is non-null.
	Client *OAuthClient `json:"client,omitempty"`
	// All deliveries which have been sent to this webhook.
	Deliveries *WebhookDeliveryCursor `json:"deliveries"`
	// Returns a sample payload for this subscription, for testing purposes
	Sample string `json:"sample"`

	// Underlying value of the GraphQL interface
	Value WebhookSubscriptionValue `json:"-"`
}

func (base *WebhookSubscription) UnmarshalJSON(b []byte) error {
	type Raw WebhookSubscription
	var data struct {
		*Raw
		TypeName string `json:"__typename"`
	}
	data.Raw = (*Raw)(base)
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}
	switch data.TypeName {
	case "ProfileWebhookSubscription":
		base.Value = new(ProfileWebhookSubscription)
	case "":
		return nil
	default:
		return fmt.Errorf("gqlclient: interface WebhookSubscription: unknown __typename %q", data.TypeName)
	}
	return json.Unmarshal(b, base.Value)
}

// WebhookSubscriptionValue is one of: ProfileWebhookSubscription
type WebhookSubscriptionValue interface {
	isWebhookSubscription()
}

// A cursor for enumerating a list of webhook subscriptions
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type WebhookSubscriptionCursor struct {
	Results []WebhookSubscription `json:"results"`
	Cursor  *Cursor               `json:"cursor,omitempty"`
}

func FetchMe(client *gqlclient.Client, ctx context.Context) (me *User, err error) {
	op := gqlclient.NewOperation("query fetchMe {\n\tme {\n\t\t... user\n\t}\n}\nfragment user on User {\n\tcanonicalName\n\temail\n\turl\n\tlocation\n\tbio\n}\n")
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func FetchUser(client *gqlclient.Client, ctx context.Context, username string) (userByName *User, err error) {
	op := gqlclient.NewOperation("query fetchUser ($username: String!) {\n\tuserByName(username: $username) {\n\t\t... user\n\t}\n}\nfragment user on User {\n\tcanonicalName\n\temail\n\turl\n\tlocation\n\tbio\n}\n")
	op.Var("username", username)
	var respData struct {
		UserByName *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UserByName, err
}

func ListSSHKeys(client *gqlclient.Client, ctx context.Context, cursor *Cursor) (me *User, err error) {
	op := gqlclient.NewOperation("query listSSHKeys ($cursor: Cursor) {\n\tme {\n\t\t... sshKeys\n\t}\n}\nfragment sshKeys on User {\n\tsshKeys(cursor: $cursor) {\n\t\tresults {\n\t\t\tid\n\t\t\tfingerprint\n\t\t\tcomment\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("cursor", cursor)
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func ListSSHKeysByUser(client *gqlclient.Client, ctx context.Context, username string, cursor *Cursor) (userByName *User, err error) {
	op := gqlclient.NewOperation("query listSSHKeysByUser ($username: String!, $cursor: Cursor) {\n\tuserByName(username: $username) {\n\t\t... sshKeys\n\t}\n}\nfragment sshKeys on User {\n\tsshKeys(cursor: $cursor) {\n\t\tresults {\n\t\t\tid\n\t\t\tfingerprint\n\t\t\tcomment\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("username", username)
	op.Var("cursor", cursor)
	var respData struct {
		UserByName *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UserByName, err
}

func ListRawSSHKeys(client *gqlclient.Client, ctx context.Context, cursor *Cursor) (me *User, err error) {
	op := gqlclient.NewOperation("query listRawSSHKeys ($cursor: Cursor) {\n\tme {\n\t\t... sshKeysRaw\n\t}\n}\nfragment sshKeysRaw on User {\n\tsshKeys(cursor: $cursor) {\n\t\tresults {\n\t\t\tkey\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("cursor", cursor)
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func ListRawSSHKeysByUser(client *gqlclient.Client, ctx context.Context, username string, cursor *Cursor) (userByName *User, err error) {
	op := gqlclient.NewOperation("query listRawSSHKeysByUser ($username: String!, $cursor: Cursor) {\n\tuserByName(username: $username) {\n\t\t... sshKeysRaw\n\t}\n}\nfragment sshKeysRaw on User {\n\tsshKeys(cursor: $cursor) {\n\t\tresults {\n\t\t\tkey\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("username", username)
	op.Var("cursor", cursor)
	var respData struct {
		UserByName *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UserByName, err
}

func ListPGPKeys(client *gqlclient.Client, ctx context.Context, cursor *Cursor) (me *User, err error) {
	op := gqlclient.NewOperation("query listPGPKeys ($cursor: Cursor) {\n\tme {\n\t\t... pgpKeys\n\t}\n}\nfragment pgpKeys on User {\n\tpgpKeys(cursor: $cursor) {\n\t\tresults {\n\t\t\tid\n\t\t\tfingerprint\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("cursor", cursor)
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func ListPGPKeysByUser(client *gqlclient.Client, ctx context.Context, username string, cursor *Cursor) (userByName *User, err error) {
	op := gqlclient.NewOperation("query listPGPKeysByUser ($username: String!, $cursor: Cursor) {\n\tuserByName(username: $username) {\n\t\t... pgpKeys\n\t}\n}\nfragment pgpKeys on User {\n\tpgpKeys(cursor: $cursor) {\n\t\tresults {\n\t\t\tid\n\t\t\tfingerprint\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("username", username)
	op.Var("cursor", cursor)
	var respData struct {
		UserByName *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UserByName, err
}

func ListRawPGPKeys(client *gqlclient.Client, ctx context.Context, cursor *Cursor) (me *User, err error) {
	op := gqlclient.NewOperation("query listRawPGPKeys ($cursor: Cursor) {\n\tme {\n\t\t... pgpKeysRaw\n\t}\n}\nfragment pgpKeysRaw on User {\n\tpgpKeys(cursor: $cursor) {\n\t\tresults {\n\t\t\tkey\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("cursor", cursor)
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func ListRawPGPKeysByUser(client *gqlclient.Client, ctx context.Context, username string, cursor *Cursor) (userByName *User, err error) {
	op := gqlclient.NewOperation("query listRawPGPKeysByUser ($username: String!, $cursor: Cursor) {\n\tuserByName(username: $username) {\n\t\t... pgpKeysRaw\n\t}\n}\nfragment pgpKeysRaw on User {\n\tpgpKeys(cursor: $cursor) {\n\t\tresults {\n\t\t\tkey\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("username", username)
	op.Var("cursor", cursor)
	var respData struct {
		UserByName *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UserByName, err
}

func AuditLog(client *gqlclient.Client, ctx context.Context, cursor *Cursor) (auditLog *AuditLogCursor, err error) {
	op := gqlclient.NewOperation("query auditLog ($cursor: Cursor) {\n\tauditLog(cursor: $cursor) {\n\t\tresults {\n\t\t\tcreated\n\t\t\tipAddress\n\t\t\teventType\n\t\t\tdetails\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("cursor", cursor)
	var respData struct {
		AuditLog *AuditLogCursor
	}
	err = client.Execute(ctx, op, &respData)
	return respData.AuditLog, err
}

func UserWebhooks(client *gqlclient.Client, ctx context.Context, cursor *Cursor) (profileWebhooks *WebhookSubscriptionCursor, err error) {
	op := gqlclient.NewOperation("query userWebhooks ($cursor: Cursor) {\n\tprofileWebhooks(cursor: $cursor) {\n\t\tresults {\n\t\t\tid\n\t\t\turl\n\t\t}\n\t\tcursor\n\t}\n}\n")
	op.Var("cursor", cursor)
	var respData struct {
		ProfileWebhooks *WebhookSubscriptionCursor
	}
	err = client.Execute(ctx, op, &respData)
	return respData.ProfileWebhooks, err
}

func PersonalAccessTokens(client *gqlclient.Client, ctx context.Context) (personalAccessTokens []OAuthPersonalToken, err error) {
	op := gqlclient.NewOperation("query personalAccessTokens {\n\tpersonalAccessTokens {\n\t\tissued\n\t\texpires\n\t\tcomment\n\t\tgrants\n\t}\n}\n")
	var respData struct {
		PersonalAccessTokens []OAuthPersonalToken
	}
	err = client.Execute(ctx, op, &respData)
	return respData.PersonalAccessTokens, err
}

func Bio(client *gqlclient.Client, ctx context.Context) (me *User, err error) {
	op := gqlclient.NewOperation("query bio {\n\tme {\n\t\tbio\n\t}\n}\n")
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func CreateSSHKey(client *gqlclient.Client, ctx context.Context, key string) (createSSHKey *SSHKey, err error) {
	op := gqlclient.NewOperation("mutation createSSHKey ($key: String!) {\n\tcreateSSHKey(key: $key) {\n\t\tfingerprint\n\t\tcomment\n\t}\n}\n")
	op.Var("key", key)
	var respData struct {
		CreateSSHKey *SSHKey
	}
	err = client.Execute(ctx, op, &respData)
	return respData.CreateSSHKey, err
}

func CreatePGPKey(client *gqlclient.Client, ctx context.Context, key string) (createPGPKey *PGPKey, err error) {
	op := gqlclient.NewOperation("mutation createPGPKey ($key: String!) {\n\tcreatePGPKey(key: $key) {\n\t\tfingerprint\n\t}\n}\n")
	op.Var("key", key)
	var respData struct {
		CreatePGPKey *PGPKey
	}
	err = client.Execute(ctx, op, &respData)
	return respData.CreatePGPKey, err
}

func DeleteSSHKey(client *gqlclient.Client, ctx context.Context, id int32) (deleteSSHKey *SSHKey, err error) {
	op := gqlclient.NewOperation("mutation deleteSSHKey ($id: Int!) {\n\tdeleteSSHKey(id: $id) {\n\t\tfingerprint\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeleteSSHKey *SSHKey
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeleteSSHKey, err
}

func DeletePGPKey(client *gqlclient.Client, ctx context.Context, id int32) (deletePGPKey *PGPKey, err error) {
	op := gqlclient.NewOperation("mutation deletePGPKey ($id: Int!) {\n\tdeletePGPKey(id: $id) {\n\t\tfingerprint\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeletePGPKey *PGPKey
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeletePGPKey, err
}

func CreateUserWebhook(client *gqlclient.Client, ctx context.Context, config ProfileWebhookInput) (createWebhook *WebhookSubscription, err error) {
	op := gqlclient.NewOperation("mutation createUserWebhook ($config: ProfileWebhookInput!) {\n\tcreateWebhook(config: $config) {\n\t\tid\n\t}\n}\n")
	op.Var("config", config)
	var respData struct {
		CreateWebhook *WebhookSubscription
	}
	err = client.Execute(ctx, op, &respData)
	return respData.CreateWebhook, err
}

func DeleteUserWebhook(client *gqlclient.Client, ctx context.Context, id int32) (deleteWebhook *WebhookSubscription, err error) {
	op := gqlclient.NewOperation("mutation deleteUserWebhook ($id: Int!) {\n\tdeleteWebhook(id: $id) {\n\t\tid\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeleteWebhook *WebhookSubscription
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeleteWebhook, err
}

func UpdateUser(client *gqlclient.Client, ctx context.Context, input *UserInput) (updateUser *User, err error) {
	op := gqlclient.NewOperation("mutation updateUser ($input: UserInput) {\n\tupdateUser(input: $input) {\n\t\tcanonicalName\n\t}\n}\n")
	op.Var("input", input)
	var respData struct {
		UpdateUser *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UpdateUser, err
}

func ClearUserLocation(client *gqlclient.Client, ctx context.Context) (updateUser *User, err error) {
	op := gqlclient.NewOperation("mutation clearUserLocation {\n\tupdateUser(input: {location:null}) {\n\t\tcanonicalName\n\t}\n}\n")
	var respData struct {
		UpdateUser *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UpdateUser, err
}

func ClearUserURL(client *gqlclient.Client, ctx context.Context) (updateUser *User, err error) {
	op := gqlclient.NewOperation("mutation clearUserURL {\n\tupdateUser(input: {url:null}) {\n\t\tcanonicalName\n\t}\n}\n")
	var respData struct {
		UpdateUser *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UpdateUser, err
}

func ClearBio(client *gqlclient.Client, ctx context.Context) (updateUser *User, err error) {
	op := gqlclient.NewOperation("mutation clearBio {\n\tupdateUser(input: {bio:null}) {\n\t\tcanonicalName\n\t}\n}\n")
	var respData struct {
		UpdateUser *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UpdateUser, err
}
