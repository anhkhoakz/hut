// Code generated by gqlclientgen - DO NOT EDIT

package gitsrht

import (
	"context"
	gqlclient "git.sr.ht/~emersion/gqlclient"
	"time"
)

type ACL struct {
	Id         int32       `json:"id"`
	Created    time.Time   `json:"created"`
	Repository *Repository `json:"repository"`
	Entity     *Entity     `json:"entity"`
	Mode       *AccessMode `json:"mode,omitempty"`
}

// A cursor for enumerating access control list entries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type ACLCursor struct {
	Results []ACL   `json:"results"`
	Cursor  *Cursor `json:"cursor,omitempty"`
}

type AccessKind string

const (
	AccessKindRo AccessKind = "RO"
	AccessKindRw AccessKind = "RW"
)

type AccessMode string

const (
	// Read-only
	AccessModeRo AccessMode = "RO"
	// Read/write
	AccessModeRw AccessMode = "RW"
)

type AccessScope string

const (
	AccessScopeProfile      AccessScope = "PROFILE"
	AccessScopeRepositories AccessScope = "REPOSITORIES"
	AccessScopeObjects      AccessScope = "OBJECTS"
	AccessScopeAcls         AccessScope = "ACLS"
)

// Arbitrary file attached to a git repository
type Artifact struct {
	Id       int32     `json:"id"`
	Created  time.Time `json:"created"`
	Filename string    `json:"filename"`
	Checksum string    `json:"checksum"`
	Size     int32     `json:"size"`
	Url      string    `json:"url"`
}

// A cursor for enumerating artifacts
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type ArtifactCursor struct {
	Results []Artifact `json:"results"`
	Cursor  *Cursor    `json:"cursor,omitempty"`
}

type BinaryBlob struct {
	Type    ObjectType `json:"type"`
	Id      string     `json:"id"`
	ShortId string     `json:"shortId"`
	Raw     string     `json:"raw"`
	Base64  string     `json:"base64"`
}

type Blob struct {
	Id string `json:"id"`
}

type Commit struct {
	Type      ObjectType `json:"type"`
	Id        string     `json:"id"`
	ShortId   string     `json:"shortId"`
	Raw       string     `json:"raw"`
	Author    *Signature `json:"author"`
	Committer *Signature `json:"committer"`
	Message   string     `json:"message"`
	Tree      *Tree      `json:"tree"`
	Parents   []Commit   `json:"parents"`
	Diff      string     `json:"diff"`
}

// A cursor for enumerating commits
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type CommitCursor struct {
	Results []Commit `json:"results"`
	Cursor  *Cursor  `json:"cursor,omitempty"`
}

type Cursor string

type Entity struct {
	Id      int32     `json:"id"`
	Created time.Time `json:"created"`
	Updated time.Time `json:"updated"`
	// The canonical name of this entity. For users, this is their username
	// prefixed with '~'. Additional entity types will be supported in the future.
	CanonicalName string `json:"canonicalName"`
	// Returns a specific repository owned by the user.
	Repository *Repository `json:"repository,omitempty"`
	// Returns repositories that the user has access to.
	//
	// NOTE: in this version of the API, only repositories owned by the
	// authenticated user are returned, but in the future the default behavior
	// will be to return all repositories that the user either (1) has been given
	// explicit access to via ACLs or (2) has implicit access to either by
	// ownership or group membership.
	Repositories *RepositoryCursor `json:"repositories"`
}

// Describes the status of optional features
type Features struct {
	Artifacts bool `json:"artifacts"`
}

type Filter struct {
	// Number of results to return.
	Count *int32 `json:"count,omitempty"`
	// Search terms. The exact meaning varies by usage, but generally these are
	// compatible with the web UI's search syntax.
	Search *string `json:"search,omitempty"`
}

type OAuthClient struct {
	Uuid string `json:"uuid"`
}

type Object struct {
	Type    ObjectType `json:"type"`
	Id      string     `json:"id"`
	ShortId string     `json:"shortId"`
	// Raw git object, base64 encoded
	Raw string `json:"raw"`
}

type ObjectType string

const (
	ObjectTypeCommit ObjectType = "COMMIT"
	ObjectTypeTree   ObjectType = "TREE"
	ObjectTypeBlob   ObjectType = "BLOB"
	ObjectTypeTag    ObjectType = "TAG"
)

type Reference struct {
	Name      string          `json:"name"`
	Target    string          `json:"target"`
	Follow    *Object         `json:"follow,omitempty"`
	Artifacts *ArtifactCursor `json:"artifacts"`
}

// A cursor for enumerating a list of references
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type ReferenceCursor struct {
	Results []Reference `json:"results"`
	Cursor  *Cursor     `json:"cursor,omitempty"`
}

type RepoInput struct {
	Name        *string     `json:"name,omitempty"`
	Description *string     `json:"description,omitempty"`
	Visibility  *Visibility `json:"visibility,omitempty"`
	// Updates the custom README associated with this repository. Note that the
	// provided HTML will be sanitized when displayed on the web; see
	// https://man.sr.ht/markdown/#post-processing
	Readme *string `json:"readme,omitempty"`
	// Updates the repository HEAD reference, which serves as the default branch.
	// Must be a valid branch name.
	HEAD *string `json:"HEAD,omitempty"`
}

type Repository struct {
	Id          int32      `json:"id"`
	Created     time.Time  `json:"created"`
	Updated     time.Time  `json:"updated"`
	Owner       *Entity    `json:"owner"`
	Name        string     `json:"name"`
	Description *string    `json:"description,omitempty"`
	Visibility  Visibility `json:"visibility"`
	// The repository's custom README, if set.
	//
	// NOTICE: This returns unsanitized HTML. It is the client's responsibility to
	// sanitize this for display on the web, if so desired.
	Readme            *string          `json:"readme,omitempty"`
	AccessControlList *ACLCursor       `json:"accessControlList"`
	Objects           []*Object        `json:"objects"`
	References        *ReferenceCursor `json:"references"`
	// The HEAD reference for this repository (equivalent to the default branch)
	HEAD *Reference `json:"HEAD,omitempty"`
	// Returns a list of comments sorted by committer time (similar to `git log`'s
	// default ordering).
	//
	// If `from` is specified, it is interpreted as a revspec to start logging
	// from. A clever reader may notice that using commits[-1].from + "^" as the
	// from parameter is equivalent to passing the cursor to the next call.
	Log *CommitCursor `json:"log"`
	// Returns a tree entry for a given path, at the given revspec.
	Path *TreeEntry `json:"path,omitempty"`
	// Returns the commit for a given revspec.
	Revparse_single *Commit `json:"revparse_single,omitempty"`
}

// A cursor for enumerating a list of repositories
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type RepositoryCursor struct {
	Results []Repository `json:"results"`
	Cursor  *Cursor      `json:"cursor,omitempty"`
}

type RepositoryEvent struct {
	Uuid       string       `json:"uuid"`
	Event      WebhookEvent `json:"event"`
	Date       time.Time    `json:"date"`
	Repository *Repository  `json:"repository"`
}

// Instance specific settings
type Settings struct {
	SshUser string `json:"sshUser"`
}

type Signature struct {
	Name  string    `json:"name"`
	Email string    `json:"email"`
	Time  time.Time `json:"time"`
}

type Tag struct {
	Type    ObjectType `json:"type"`
	Id      string     `json:"id"`
	ShortId string     `json:"shortId"`
	Raw     string     `json:"raw"`
	Target  *Object    `json:"target"`
	Name    string     `json:"name"`
	Tagger  *Signature `json:"tagger"`
	Message *string    `json:"message,omitempty"`
}

type TextBlob struct {
	Type    ObjectType `json:"type"`
	Id      string     `json:"id"`
	ShortId string     `json:"shortId"`
	Raw     string     `json:"raw"`
	Text    string     `json:"text"`
}

type Tree struct {
	Type    ObjectType       `json:"type"`
	Id      string           `json:"id"`
	ShortId string           `json:"shortId"`
	Raw     string           `json:"raw"`
	Entries *TreeEntryCursor `json:"entries"`
	Entry   *TreeEntry       `json:"entry,omitempty"`
}

type TreeEntry struct {
	Id     string  `json:"id"`
	Name   string  `json:"name"`
	Object *Object `json:"object"`
	// Unix-style file mode, i.e. 0755 or 0644 (octal)
	Mode int32 `json:"mode"`
}

// A cursor for enumerating tree entries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type TreeEntryCursor struct {
	Results []TreeEntry `json:"results"`
	Cursor  *Cursor     `json:"cursor,omitempty"`
}

type User struct {
	Id            int32             `json:"id"`
	Created       time.Time         `json:"created"`
	Updated       time.Time         `json:"updated"`
	CanonicalName string            `json:"canonicalName"`
	Username      string            `json:"username"`
	Email         string            `json:"email"`
	Url           *string           `json:"url,omitempty"`
	Location      *string           `json:"location,omitempty"`
	Bio           *string           `json:"bio,omitempty"`
	Repository    *Repository       `json:"repository,omitempty"`
	Repositories  *RepositoryCursor `json:"repositories"`
}

type UserWebhookInput struct {
	Url    string         `json:"url"`
	Events []WebhookEvent `json:"events"`
	Query  string         `json:"query"`
}

type UserWebhookSubscription struct {
	Id         int32                  `json:"id"`
	Events     []WebhookEvent         `json:"events"`
	Query      string                 `json:"query"`
	Url        string                 `json:"url"`
	Client     *OAuthClient           `json:"client,omitempty"`
	Deliveries *WebhookDeliveryCursor `json:"deliveries"`
	Sample     string                 `json:"sample"`
}

type Version struct {
	Major int32 `json:"major"`
	Minor int32 `json:"minor"`
	Patch int32 `json:"patch"`
	// If this API version is scheduled for deprecation, this is the date on which
	// it will stop working; or null if this API version is not scheduled for
	// deprecation.
	DeprecationDate time.Time `json:"deprecationDate,omitempty"`
	// Optional features
	Features *Features `json:"features"`
	// Config settings
	Settings *Settings `json:"settings"`
}

type Visibility string

const (
	// Visible to everyone, listed on your profile
	VisibilityPublic Visibility = "PUBLIC"
	// Visible to everyone (if they know the URL), not listed on your profile
	VisibilityUnlisted Visibility = "UNLISTED"
	// Not visible to anyone except those explicitly added to the access list
	VisibilityPrivate Visibility = "PRIVATE"
)

type WebhookDelivery struct {
	Uuid         string               `json:"uuid"`
	Date         time.Time            `json:"date"`
	Event        WebhookEvent         `json:"event"`
	Subscription *WebhookSubscription `json:"subscription"`
	RequestBody  string               `json:"requestBody"`
	// These details are provided only after a response is received from the
	// remote server. If a response is sent whose Content-Type is not text/*, or
	// cannot be decoded as UTF-8, the response body will be null. It will be
	// truncated after 64 KiB.
	ResponseBody    *string `json:"responseBody,omitempty"`
	ResponseHeaders *string `json:"responseHeaders,omitempty"`
	ResponseStatus  *int32  `json:"responseStatus,omitempty"`
}

// A cursor for enumerating a list of webhook deliveries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type WebhookDeliveryCursor struct {
	Results []WebhookDelivery `json:"results"`
	Cursor  *Cursor           `json:"cursor,omitempty"`
}

type WebhookEvent string

const (
	WebhookEventRepoCreated WebhookEvent = "REPO_CREATED"
	WebhookEventRepoUpdate  WebhookEvent = "REPO_UPDATE"
	WebhookEventRepoDeleted WebhookEvent = "REPO_DELETED"
)

type WebhookPayload struct {
	Uuid  string       `json:"uuid"`
	Event WebhookEvent `json:"event"`
	Date  time.Time    `json:"date"`
}

type WebhookSubscription struct {
	Id     int32          `json:"id"`
	Events []WebhookEvent `json:"events"`
	Query  string         `json:"query"`
	Url    string         `json:"url"`
	// If this webhook was registered by an authorized OAuth 2.0 client, this
	// field is non-null.
	Client *OAuthClient `json:"client,omitempty"`
	// All deliveries which have been sent to this webhook.
	Deliveries *WebhookDeliveryCursor `json:"deliveries"`
	// Returns a sample payload for this subscription, for testing purposes
	Sample string `json:"sample"`
}

// A cursor for enumerating a list of webhook subscriptions
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type WebhookSubscriptionCursor struct {
	Results []WebhookSubscription `json:"results"`
	Cursor  *Cursor               `json:"cursor,omitempty"`
}

func RepositoryIDByName(client *gqlclient.Client, ctx context.Context, name string) (me *User, err error) {
	op := gqlclient.NewOperation("query repositoryIDByName ($name: String!) {\n\tme {\n\t\trepository(name: $name) {\n\t\t\tid\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func RepositoryIDByUser(client *gqlclient.Client, ctx context.Context, username string, name string) (user *User, err error) {
	op := gqlclient.NewOperation("query repositoryIDByUser ($username: String!, $name: String!) {\n\tuser(username: $username) {\n\t\trepository(name: $name) {\n\t\t\tid\n\t\t}\n\t}\n}\n")
	op.Var("username", username)
	op.Var("name", name)
	var respData struct {
		User *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.User, err
}

func ListArtifacts(client *gqlclient.Client, ctx context.Context, name string) (me *User, err error) {
	op := gqlclient.NewOperation("query listArtifacts ($name: String!) {\n\tme {\n\t\trepository(name: $name) {\n\t\t\t... artifacts\n\t\t}\n\t}\n}\nfragment artifacts on Repository {\n\treferences {\n\t\tresults {\n\t\t\tname\n\t\t\tartifacts {\n\t\t\t\tresults {\n\t\t\t\t\tid\n\t\t\t\t\tfilename\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func ListArtifactsByUser(client *gqlclient.Client, ctx context.Context, username string, name string) (user *User, err error) {
	op := gqlclient.NewOperation("query listArtifactsByUser ($username: String!, $name: String!) {\n\tuser(username: $username) {\n\t\trepository(name: $name) {\n\t\t\t... artifacts\n\t\t}\n\t}\n}\nfragment artifacts on Repository {\n\treferences {\n\t\tresults {\n\t\t\tname\n\t\t\tartifacts {\n\t\t\t\tresults {\n\t\t\t\t\tid\n\t\t\t\t\tfilename\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("username", username)
	op.Var("name", name)
	var respData struct {
		User *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.User, err
}

func RepositoryByName(client *gqlclient.Client, ctx context.Context, name string) (me *User, err error) {
	op := gqlclient.NewOperation("query repositoryByName ($name: String!) {\n\tme {\n\t\trepository(name: $name) {\n\t\t\t... repository\n\t\t}\n\t}\n}\nfragment repository on Repository {\n\tname\n\tdescription\n\tvisibility\n\treferences {\n\t\tresults {\n\t\t\tname\n\t\t}\n\t}\n\tlog {\n\t\tresults {\n\t\t\tshortId\n\t\t\tauthor {\n\t\t\t\tname\n\t\t\t\temail\n\t\t\t\ttime\n\t\t\t}\n\t\t\tmessage\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func RepositoryByUser(client *gqlclient.Client, ctx context.Context, username string, name string) (user *User, err error) {
	op := gqlclient.NewOperation("query repositoryByUser ($username: String!, $name: String!) {\n\tuser(username: $username) {\n\t\trepository(name: $name) {\n\t\t\t... repository\n\t\t}\n\t}\n}\nfragment repository on Repository {\n\tname\n\tdescription\n\tvisibility\n\treferences {\n\t\tresults {\n\t\t\tname\n\t\t}\n\t}\n\tlog {\n\t\tresults {\n\t\t\tshortId\n\t\t\tauthor {\n\t\t\t\tname\n\t\t\t\temail\n\t\t\t\ttime\n\t\t\t}\n\t\t\tmessage\n\t\t}\n\t}\n}\n")
	op.Var("username", username)
	op.Var("name", name)
	var respData struct {
		User *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.User, err
}

func Repositories(client *gqlclient.Client, ctx context.Context) (repositories *RepositoryCursor, err error) {
	op := gqlclient.NewOperation("query repositories {\n\trepositories {\n\t\t... repos\n\t}\n}\nfragment repos on RepositoryCursor {\n\tresults {\n\t\tname\n\t\tdescription\n\t\tvisibility\n\t\towner {\n\t\t\tcanonicalName\n\t\t}\n\t}\n}\n")
	var respData struct {
		Repositories *RepositoryCursor
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Repositories, err
}

func RepositoriesByUser(client *gqlclient.Client, ctx context.Context, username string) (user *User, err error) {
	op := gqlclient.NewOperation("query repositoriesByUser ($username: String!) {\n\tuser(username: $username) {\n\t\trepositories {\n\t\t\t... repos\n\t\t}\n\t}\n}\nfragment repos on RepositoryCursor {\n\tresults {\n\t\tname\n\t\tdescription\n\t\tvisibility\n\t\towner {\n\t\t\tcanonicalName\n\t\t}\n\t}\n}\n")
	op.Var("username", username)
	var respData struct {
		User *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.User, err
}

func SshSettings(client *gqlclient.Client, ctx context.Context) (version *Version, err error) {
	op := gqlclient.NewOperation("query sshSettings {\n\tversion {\n\t\tsettings {\n\t\t\tsshUser\n\t\t}\n\t}\n}\n")
	var respData struct {
		Version *Version
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Version, err
}

func RepoNames(client *gqlclient.Client, ctx context.Context) (repositories *RepositoryCursor, err error) {
	op := gqlclient.NewOperation("query repoNames {\n\trepositories {\n\t\tresults {\n\t\t\tname\n\t\t}\n\t}\n}\n")
	var respData struct {
		Repositories *RepositoryCursor
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Repositories, err
}

func RevsByRepoName(client *gqlclient.Client, ctx context.Context, name string) (me *User, err error) {
	op := gqlclient.NewOperation("query revsByRepoName ($name: String!) {\n\tme {\n\t\trepository(name: $name) {\n\t\t\treferences {\n\t\t\t\tresults {\n\t\t\t\t\tname\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func AclByRepoName(client *gqlclient.Client, ctx context.Context, name string) (me *User, err error) {
	op := gqlclient.NewOperation("query aclByRepoName ($name: String!) {\n\tme {\n\t\trepository(name: $name) {\n\t\t\taccessControlList {\n\t\t\t\tresults {\n\t\t\t\t\tid\n\t\t\t\t\tcreated\n\t\t\t\t\tentity {\n\t\t\t\t\t\tcanonicalName\n\t\t\t\t\t}\n\t\t\t\t\tmode\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		Me *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, err
}

func UserWebhooks(client *gqlclient.Client, ctx context.Context) (userWebhooks *WebhookSubscriptionCursor, err error) {
	op := gqlclient.NewOperation("query userWebhooks {\n\tuserWebhooks {\n\t\tresults {\n\t\t\tid\n\t\t\tevents\n\t\t\tquery\n\t\t\turl\n\t\t}\n\t}\n}\n")
	var respData struct {
		UserWebhooks *WebhookSubscriptionCursor
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UserWebhooks, err
}

func CompleteUserWebhookId(client *gqlclient.Client, ctx context.Context) (userWebhooks *WebhookSubscriptionCursor, err error) {
	op := gqlclient.NewOperation("query completeUserWebhookId {\n\tuserWebhooks {\n\t\tresults {\n\t\t\tid\n\t\t\turl\n\t\t}\n\t}\n}\n")
	var respData struct {
		UserWebhooks *WebhookSubscriptionCursor
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UserWebhooks, err
}

func UploadArtifact(client *gqlclient.Client, ctx context.Context, repoId int32, revspec string, file gqlclient.Upload) (uploadArtifact *Artifact, err error) {
	op := gqlclient.NewOperation("mutation uploadArtifact ($repoId: Int!, $revspec: String!, $file: Upload!) {\n\tuploadArtifact(repoId: $repoId, revspec: $revspec, file: $file) {\n\t\tfilename\n\t}\n}\n")
	op.Var("repoId", repoId)
	op.Var("revspec", revspec)
	op.Var("file", file)
	var respData struct {
		UploadArtifact *Artifact
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UploadArtifact, err
}

func DeleteArtifact(client *gqlclient.Client, ctx context.Context, id int32) (deleteArtifact *Artifact, err error) {
	op := gqlclient.NewOperation("mutation deleteArtifact ($id: Int!) {\n\tdeleteArtifact(id: $id) {\n\t\tfilename\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeleteArtifact *Artifact
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeleteArtifact, err
}

func CreateRepository(client *gqlclient.Client, ctx context.Context, name string, visibility Visibility, description string, cloneUrl *string) (createRepository *Repository, err error) {
	op := gqlclient.NewOperation("mutation createRepository ($name: String!, $visibility: Visibility!, $description: String!, $cloneUrl: String) {\n\tcreateRepository(name: $name, visibility: $visibility, description: $description, cloneUrl: $cloneUrl) {\n\t\towner {\n\t\t\tcanonicalName\n\t\t}\n\t\tname\n\t}\n}\n")
	op.Var("name", name)
	op.Var("visibility", visibility)
	op.Var("description", description)
	op.Var("cloneUrl", cloneUrl)
	var respData struct {
		CreateRepository *Repository
	}
	err = client.Execute(ctx, op, &respData)
	return respData.CreateRepository, err
}

func DeleteRepository(client *gqlclient.Client, ctx context.Context, id int32) (deleteRepository *Repository, err error) {
	op := gqlclient.NewOperation("mutation deleteRepository ($id: Int!) {\n\tdeleteRepository(id: $id) {\n\t\tname\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeleteRepository *Repository
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeleteRepository, err
}

func UpdateACL(client *gqlclient.Client, ctx context.Context, repoId int32, mode AccessMode, entity string) (updateACL *ACL, err error) {
	op := gqlclient.NewOperation("mutation updateACL ($repoId: Int!, $mode: AccessMode!, $entity: ID!) {\n\tupdateACL(repoId: $repoId, mode: $mode, entity: $entity) {\n\t\tentity {\n\t\t\tcanonicalName\n\t\t}\n\t}\n}\n")
	op.Var("repoId", repoId)
	op.Var("mode", mode)
	op.Var("entity", entity)
	var respData struct {
		UpdateACL *ACL
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UpdateACL, err
}

func DeleteACL(client *gqlclient.Client, ctx context.Context, id int32) (deleteACL *ACL, err error) {
	op := gqlclient.NewOperation("mutation deleteACL ($id: Int!) {\n\tdeleteACL(id: $id) {\n\t\tentity {\n\t\t\tcanonicalName\n\t\t}\n\t\trepository {\n\t\t\tname\n\t\t}\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeleteACL *ACL
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeleteACL, err
}

func DeleteUserWebhook(client *gqlclient.Client, ctx context.Context, id int32) (deleteWebhook *WebhookSubscription, err error) {
	op := gqlclient.NewOperation("mutation deleteUserWebhook ($id: Int!) {\n\tdeleteWebhook(id: $id) {\n\t\tid\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeleteWebhook *WebhookSubscription
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeleteWebhook, err
}

func CreateUserWebhook(client *gqlclient.Client, ctx context.Context, config UserWebhookInput) (createWebhook *WebhookSubscription, err error) {
	op := gqlclient.NewOperation("mutation createUserWebhook ($config: UserWebhookInput!) {\n\tcreateWebhook(config: $config) {\n\t\tid\n\t}\n}\n")
	op.Var("config", config)
	var respData struct {
		CreateWebhook *WebhookSubscription
	}
	err = client.Execute(ctx, op, &respData)
	return respData.CreateWebhook, err
}
