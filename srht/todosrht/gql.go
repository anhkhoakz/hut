// Code generated by gqlclientgen - DO NOT EDIT

package todosrht

import (
	"context"
	gqlclient "git.sr.ht/~emersion/gqlclient"
	"time"
)

type ACL struct {
	// Permission to view tickets
	Browse bool `json:"browse"`
	// Permission to submit tickets
	Submit bool `json:"submit"`
	// Permission to comment on tickets
	Comment bool `json:"comment"`
	// Permission to edit tickets
	Edit bool `json:"edit"`
	// Permission to resolve, re-open, transfer, or label tickets
	Triage bool `json:"triage"`
}

// A cursor for enumerating access control list entries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type ACLCursor struct {
	Results []TrackerACL `json:"results"`
	Cursor  *Cursor      `json:"cursor,omitempty"`
}

type ACLInput struct {
	// Permission to view tickets
	Browse bool `json:"browse"`
	// Permission to submit tickets
	Submit bool `json:"submit"`
	// Permission to comment on tickets
	Comment bool `json:"comment"`
	// Permission to edit tickets
	Edit bool `json:"edit"`
	// Permission to resolve, re-open, transfer, or label tickets
	Triage bool `json:"triage"`
}

type AccessKind string

const (
	AccessKindRo AccessKind = "RO"
	AccessKindRw AccessKind = "RW"
)

type AccessScope string

const (
	AccessScopeProfile       AccessScope = "PROFILE"
	AccessScopeTrackers      AccessScope = "TRACKERS"
	AccessScopeTickets       AccessScope = "TICKETS"
	AccessScopeAcls          AccessScope = "ACLS"
	AccessScopeEvents        AccessScope = "EVENTS"
	AccessScopeSubscriptions AccessScope = "SUBSCRIPTIONS"
)

type ActivitySubscription struct {
	Id      int32     `json:"id"`
	Created time.Time `json:"created"`
}

// A cursor for enumerating subscriptions
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type ActivitySubscriptionCursor struct {
	Results []ActivitySubscription `json:"results"`
	Cursor  *Cursor                `json:"cursor,omitempty"`
}

type Assignment struct {
	EventType EventType `json:"eventType"`
	Ticket    *Ticket   `json:"ticket"`
	Assigner  *Entity   `json:"assigner"`
	Assignee  *Entity   `json:"assignee"`
}

type Authenticity string

const (
	// The server vouches for this information as entered verbatim by the
	// attributed entity.
	AuthenticityAuthentic Authenticity = "AUTHENTIC"
	// The server does not vouch for this information as entered by the attributed
	// entity, no authentication was provided.
	AuthenticityUnauthenticated Authenticity = "UNAUTHENTICATED"
	// The server has evidence that the information has likely been manipulated by
	// a third-party.
	AuthenticityTampered Authenticity = "TAMPERED"
)

type Comment struct {
	EventType    EventType    `json:"eventType"`
	Ticket       *Ticket      `json:"ticket"`
	Author       *Entity      `json:"author"`
	Text         string       `json:"text"`
	Authenticity Authenticity `json:"authenticity"`
	// If this comment has been edited, this field points to the new revision.
	SupersededBy *Comment `json:"supersededBy,omitempty"`
}

type Created struct {
	EventType EventType `json:"eventType"`
	Ticket    *Ticket   `json:"ticket"`
	Author    *Entity   `json:"author"`
}

type Cursor string

// These ACL policies are applied non-specifically, e.g. the default ACL for all
// authenticated users.
type DefaultACL struct {
	Browse  bool `json:"browse"`
	Submit  bool `json:"submit"`
	Comment bool `json:"comment"`
	Edit    bool `json:"edit"`
	Triage  bool `json:"triage"`
}

type EmailAddress struct {
	CanonicalName string `json:"canonicalName"`
	// "jdoe@example.org" of "Jane Doe <jdoe@example.org>"
	Mailbox string `json:"mailbox"`
	// "Jane Doe" of "Jane Doe <jdoe@example.org>"
	Name *string `json:"name,omitempty"`
}

type Entity struct {
	CanonicalName string `json:"canonicalName"`
}

// Represents an event which affects a ticket. Multiple changes can occur in a
// single event, and are enumerated in the "changes" field.
type Event struct {
	Id      int32         `json:"id"`
	Created time.Time     `json:"created"`
	Changes []EventDetail `json:"changes"`
	Ticket  *Ticket       `json:"ticket"`
}

// A cursor for enumerating events
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type EventCursor struct {
	Results []Event `json:"results"`
	Cursor  *Cursor `json:"cursor,omitempty"`
}

type EventDetail struct {
	EventType EventType `json:"eventType"`
	Ticket    *Ticket   `json:"ticket"`
}

type EventType string

const (
	EventTypeCreated         EventType = "CREATED"
	EventTypeComment         EventType = "COMMENT"
	EventTypeStatusChange    EventType = "STATUS_CHANGE"
	EventTypeLabelAdded      EventType = "LABEL_ADDED"
	EventTypeLabelRemoved    EventType = "LABEL_REMOVED"
	EventTypeAssignedUser    EventType = "ASSIGNED_USER"
	EventTypeUnassignedUser  EventType = "UNASSIGNED_USER"
	EventTypeUserMentioned   EventType = "USER_MENTIONED"
	EventTypeTicketMentioned EventType = "TICKET_MENTIONED"
)

type ExternalUser struct {
	CanonicalName string `json:"canonicalName"`
	// <service>:<service specific details...>
	// e.g. github:ddevault
	ExternalId string `json:"externalId"`
	// The canonical external URL for this user, e.g. https://github.com/ddevault
	ExternalUrl *string `json:"externalUrl,omitempty"`
}

// This is used for importing tickets from third-party services, and may only be
// used by the tracker owner. It causes a ticket submission, update, or comment
// to be attributed to an external user and appear as if it were submitted at a
// specific time.
type ImportInput struct {
	Created time.Time `json:"created"`
	// External user ID. By convention this should be "service:username", e.g.
	// "codeberg:ddevault".
	ExternalId string `json:"externalId"`
	// A URL at which the user's external profile may be found, e.g.
	// "https://codeberg.org/ddevault".
	ExternalUrl string `json:"externalUrl"`
}

type Label struct {
	Id      int32     `json:"id"`
	Created time.Time `json:"created"`
	Name    string    `json:"name"`
	Tracker *Tracker  `json:"tracker"`
	// In CSS hexadecimal format
	BackgroundColor string        `json:"backgroundColor"`
	ForegroundColor string        `json:"foregroundColor"`
	Tickets         *TicketCursor `json:"tickets"`
}

// A cursor for enumerating labels
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type LabelCursor struct {
	Results []Label `json:"results"`
	Cursor  *Cursor `json:"cursor,omitempty"`
}

type LabelUpdate struct {
	EventType EventType `json:"eventType"`
	Ticket    *Ticket   `json:"ticket"`
	Labeler   *Entity   `json:"labeler"`
	Label     *Label    `json:"label"`
}

type StatusChange struct {
	EventType     EventType        `json:"eventType"`
	Ticket        *Ticket          `json:"ticket"`
	Editor        *Entity          `json:"editor"`
	OldStatus     TicketStatus     `json:"oldStatus"`
	NewStatus     TicketStatus     `json:"newStatus"`
	OldResolution TicketResolution `json:"oldResolution"`
	NewResolution TicketResolution `json:"newResolution"`
}

// You may omit the status or resolution fields to leave them unchanged (or if
// you do not have permission to change them). "resolution" is required if
// status is RESOLVED.
type SubmitCommentInput struct {
	Text       string            `json:"text"`
	Status     *TicketStatus     `json:"status,omitempty"`
	Resolution *TicketResolution `json:"resolution,omitempty"`
	// For use by the tracker owner only
	Import *ImportInput `json:"import,omitempty"`
}

type SubmitTicketInput struct {
	Subject     string    `json:"subject"`
	Body        *string   `json:"body,omitempty"`
	Created     time.Time `json:"created,omitempty"`
	ExternalId  *string   `json:"externalId,omitempty"`
	ExternalUrl *string   `json:"externalUrl,omitempty"`
}

type Ticket struct {
	// The ticket ID is unique within each tracker, but is not globally unique.
	// The first ticket opened on a given tracker will have ID 1, then 2, and so
	// on.
	Id        int32     `json:"id"`
	Created   time.Time `json:"created"`
	Updated   time.Time `json:"updated"`
	Submitter *Entity   `json:"submitter"`
	Tracker   *Tracker  `json:"tracker"`
	// Canonical ticket reference string; may be used in comments to identify the
	// ticket from anywhere.
	Ref          string           `json:"ref"`
	Subject      string           `json:"subject"`
	Body         *string          `json:"body,omitempty"`
	Status       TicketStatus     `json:"status"`
	Resolution   TicketResolution `json:"resolution"`
	Authenticity Authenticity     `json:"authenticity"`
	Labels       []Label          `json:"labels"`
	Assignees    []Entity         `json:"assignees"`
	Events       *EventCursor     `json:"events"`
	// If the authenticated user is subscribed to this ticket, this is that
	// subscription.
	Subscription *TicketSubscription `json:"subscription,omitempty"`
}

// A cursor for enumerating tickets
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type TicketCursor struct {
	Results []Ticket `json:"results"`
	Cursor  *Cursor  `json:"cursor,omitempty"`
}

type TicketMention struct {
	EventType EventType `json:"eventType"`
	Ticket    *Ticket   `json:"ticket"`
	Author    *Entity   `json:"author"`
	Mentioned *Ticket   `json:"mentioned"`
}

type TicketResolution string

const (
	TicketResolutionUnresolved  TicketResolution = "UNRESOLVED"
	TicketResolutionFixed       TicketResolution = "FIXED"
	TicketResolutionImplemented TicketResolution = "IMPLEMENTED"
	TicketResolutionWontFix     TicketResolution = "WONT_FIX"
	TicketResolutionByDesign    TicketResolution = "BY_DESIGN"
	TicketResolutionInvalid     TicketResolution = "INVALID"
	TicketResolutionDuplicate   TicketResolution = "DUPLICATE"
	TicketResolutionNotOurBug   TicketResolution = "NOT_OUR_BUG"
)

type TicketStatus string

const (
	TicketStatusReported   TicketStatus = "REPORTED"
	TicketStatusConfirmed  TicketStatus = "CONFIRMED"
	TicketStatusInProgress TicketStatus = "IN_PROGRESS"
	TicketStatusPending    TicketStatus = "PENDING"
	TicketStatusResolved   TicketStatus = "RESOLVED"
)

// A ticket subscription will notify a participant when activity occurs on a
// ticket.
type TicketSubscription struct {
	Id      int32     `json:"id"`
	Created time.Time `json:"created"`
	Ticket  *Ticket   `json:"ticket"`
}

type Tracker struct {
	Id          int32         `json:"id"`
	Created     time.Time     `json:"created"`
	Updated     time.Time     `json:"updated"`
	Owner       *Entity       `json:"owner"`
	Name        string        `json:"name"`
	Description *string       `json:"description,omitempty"`
	Visibility  Visibility    `json:"visibility"`
	Ticket      *Ticket       `json:"ticket"`
	Tickets     *TicketCursor `json:"tickets"`
	Labels      *LabelCursor  `json:"labels"`
	// If the authenticated user is subscribed to this tracker, this is that
	// subscription.
	Subscription *TrackerSubscription `json:"subscription,omitempty"`
	// The access control list entry (or the default ACL) which describes the
	// authenticated user's permissions with respect to this tracker.
	Acl        *ACL        `json:"acl,omitempty"`
	DefaultACL *DefaultACL `json:"defaultACL"`
	Acls       *ACLCursor  `json:"acls"`
	// Returns a URL from which the tracker owner may download a gzipped JSON
	// archive of the tracker.
	Export URL `json:"export"`
}

// These ACLs are configured for specific entities, and may be used to expand or
// constrain the rights of a participant.
type TrackerACL struct {
	Id      int32     `json:"id"`
	Created time.Time `json:"created"`
	Tracker *Tracker  `json:"tracker"`
	Entity  *Entity   `json:"entity"`
	Browse  bool      `json:"browse"`
	Submit  bool      `json:"submit"`
	Comment bool      `json:"comment"`
	Edit    bool      `json:"edit"`
	Triage  bool      `json:"triage"`
}

// A cursor for enumerating trackers
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type TrackerCursor struct {
	Results []Tracker `json:"results"`
	Cursor  *Cursor   `json:"cursor,omitempty"`
}

// You may omit any fields to leave them unchanged.
type TrackerInput struct {
	Description *string     `json:"description,omitempty"`
	Visibility  *Visibility `json:"visibility,omitempty"`
}

// A tracker subscription will notify a participant of all activity for a
// tracker, including all new tickets and their events.
type TrackerSubscription struct {
	Id      int32     `json:"id"`
	Created time.Time `json:"created"`
	Tracker *Tracker  `json:"tracker"`
}

type URL string

// You may omit any fields to leave them unchanged.
type UpdateLabelInput struct {
	Name            *string `json:"name,omitempty"`
	ForegroundColor *string `json:"foregroundColor,omitempty"`
	BackgroundColor *string `json:"backgroundColor,omitempty"`
}

// "resolution" is required if status is RESOLVED.
type UpdateStatusInput struct {
	Status     TicketStatus      `json:"status"`
	Resolution *TicketResolution `json:"resolution,omitempty"`
	// For use by the tracker owner only
	Import *ImportInput `json:"import,omitempty"`
}

// You may omit any fields to leave them unchanged. To remove the ticket body,
// set it to null.
type UpdateTicketInput struct {
	Subject *string `json:"subject,omitempty"`
	Body    *string `json:"body,omitempty"`
	// For use by the tracker owner only
	Import *ImportInput `json:"import,omitempty"`
}

type User struct {
	Id            int32          `json:"id"`
	Created       time.Time      `json:"created"`
	Updated       time.Time      `json:"updated"`
	CanonicalName string         `json:"canonicalName"`
	Username      string         `json:"username"`
	Email         string         `json:"email"`
	Url           *string        `json:"url,omitempty"`
	Location      *string        `json:"location,omitempty"`
	Bio           *string        `json:"bio,omitempty"`
	Trackers      *TrackerCursor `json:"trackers"`
}

type UserMention struct {
	EventType EventType `json:"eventType"`
	Ticket    *Ticket   `json:"ticket"`
	Author    *Entity   `json:"author"`
	Mentioned *Entity   `json:"mentioned"`
}

type Version struct {
	Major int32 `json:"major"`
	Minor int32 `json:"minor"`
	Patch int32 `json:"patch"`
	// If this API version is scheduled for deprecation, this is the date on which
	// it will stop working; or null if this API version is not scheduled for
	// deprecation.
	DeprecationDate time.Time `json:"deprecationDate,omitempty"`
}

type Visibility string

const (
	VisibilityPublic   Visibility = "PUBLIC"
	VisibilityUnlisted Visibility = "UNLISTED"
	VisibilityPrivate  Visibility = "PRIVATE"
)

func Trackers(client *gqlclient.Client, ctx context.Context) (trackers *TrackerCursor, err error) {
	op := gqlclient.NewOperation("query trackers {\n\ttrackers {\n\t\t... trackers\n\t}\n}\nfragment trackers on TrackerCursor {\n\tresults {\n\t\tname\n\t\tdescription\n\t\tvisibility\n\t}\n}\n")
	var respData struct {
		Trackers *TrackerCursor
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Trackers, err
}

func TrackersByUser(client *gqlclient.Client, ctx context.Context, username string) (user *User, err error) {
	op := gqlclient.NewOperation("query trackersByUser ($username: String!) {\n\tuser(username: $username) {\n\t\ttrackers {\n\t\t\t... trackers\n\t\t}\n\t}\n}\nfragment trackers on TrackerCursor {\n\tresults {\n\t\tname\n\t\tdescription\n\t\tvisibility\n\t}\n}\n")
	op.Var("username", username)
	var respData struct {
		User *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.User, err
}

func TrackerIDByName(client *gqlclient.Client, ctx context.Context, name string) (trackerByName *Tracker, err error) {
	op := gqlclient.NewOperation("query trackerIDByName ($name: String!) {\n\ttrackerByName(name: $name) {\n\t\tid\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		TrackerByName *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByName, err
}

func TrackerIDByOwner(client *gqlclient.Client, ctx context.Context, owner string, tracker string) (trackerByOwner *Tracker, err error) {
	op := gqlclient.NewOperation("query trackerIDByOwner ($owner: String!, $tracker: String!) {\n\ttrackerByOwner(owner: $owner, tracker: $tracker) {\n\t\tid\n\t}\n}\n")
	op.Var("owner", owner)
	op.Var("tracker", tracker)
	var respData struct {
		TrackerByOwner *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByOwner, err
}

func Tickets(client *gqlclient.Client, ctx context.Context, name string) (trackerByName *Tracker, err error) {
	op := gqlclient.NewOperation("query tickets ($name: String!) {\n\ttrackerByName(name: $name) {\n\t\ttickets {\n\t\t\t... tickets\n\t\t}\n\t}\n}\nfragment tickets on TicketCursor {\n\tresults {\n\t\tid\n\t\tsubject\n\t\tstatus\n\t\tresolution\n\t\tcreated\n\t\tsubmitter {\n\t\t\tcanonicalName\n\t\t}\n\t\tlabels {\n\t\t\tname\n\t\t\tbackgroundColor\n\t\t\tforegroundColor\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		TrackerByName *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByName, err
}

func TicketsByOwner(client *gqlclient.Client, ctx context.Context, owner string, tracker string) (trackerByOwner *Tracker, err error) {
	op := gqlclient.NewOperation("query ticketsByOwner ($owner: String!, $tracker: String!) {\n\ttrackerByOwner(owner: $owner, tracker: $tracker) {\n\t\ttickets {\n\t\t\t... tickets\n\t\t}\n\t}\n}\nfragment tickets on TicketCursor {\n\tresults {\n\t\tid\n\t\tsubject\n\t\tstatus\n\t\tresolution\n\t\tcreated\n\t\tsubmitter {\n\t\t\tcanonicalName\n\t\t}\n\t\tlabels {\n\t\t\tname\n\t\t\tbackgroundColor\n\t\t\tforegroundColor\n\t\t}\n\t}\n}\n")
	op.Var("owner", owner)
	op.Var("tracker", tracker)
	var respData struct {
		TrackerByOwner *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByOwner, err
}

func Labels(client *gqlclient.Client, ctx context.Context, name string) (trackerByName *Tracker, err error) {
	op := gqlclient.NewOperation("query labels ($name: String!) {\n\ttrackerByName(name: $name) {\n\t\tlabels {\n\t\t\t... labels\n\t\t}\n\t}\n}\nfragment labels on LabelCursor {\n\tresults {\n\t\tid\n\t\tname\n\t\tbackgroundColor\n\t\tforegroundColor\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		TrackerByName *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByName, err
}

func LabelsByOwner(client *gqlclient.Client, ctx context.Context, owner string, tracker string) (trackerByOwner *Tracker, err error) {
	op := gqlclient.NewOperation("query labelsByOwner ($owner: String!, $tracker: String!) {\n\ttrackerByOwner(owner: $owner, tracker: $tracker) {\n\t\tlabels {\n\t\t\t... labels\n\t\t}\n\t}\n}\nfragment labels on LabelCursor {\n\tresults {\n\t\tid\n\t\tname\n\t\tbackgroundColor\n\t\tforegroundColor\n\t}\n}\n")
	op.Var("owner", owner)
	op.Var("tracker", tracker)
	var respData struct {
		TrackerByOwner *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByOwner, err
}

func AclByTrackerName(client *gqlclient.Client, ctx context.Context, name string) (trackerByName *Tracker, err error) {
	op := gqlclient.NewOperation("query aclByTrackerName ($name: String!) {\n\ttrackerByName(name: $name) {\n\t\tdefaultACL {\n\t\t\tbrowse\n\t\t\tsubmit\n\t\t\tcomment\n\t\t\tedit\n\t\t\ttriage\n\t\t}\n\t\tacls {\n\t\t\tresults {\n\t\t\t\tid\n\t\t\t\tcreated\n\t\t\t\tentity {\n\t\t\t\t\tcanonicalName\n\t\t\t\t}\n\t\t\t\tbrowse\n\t\t\t\tsubmit\n\t\t\t\tcomment\n\t\t\t\tedit\n\t\t\t\ttriage\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		TrackerByName *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByName, err
}

func UserIDByName(client *gqlclient.Client, ctx context.Context, username string) (user *User, err error) {
	op := gqlclient.NewOperation("query userIDByName ($username: String!) {\n\tuser(username: $username) {\n\t\tid\n\t}\n}\n")
	op.Var("username", username)
	var respData struct {
		User *User
	}
	err = client.Execute(ctx, op, &respData)
	return respData.User, err
}

func Assignees(client *gqlclient.Client, ctx context.Context, name string, id int32) (trackerByName *Tracker, err error) {
	op := gqlclient.NewOperation("query assignees ($name: String!, $id: Int!) {\n\ttrackerByName(name: $name) {\n\t\tticket(id: $id) {\n\t\t\tassignees {\n\t\t\t\tcanonicalName\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	op.Var("id", id)
	var respData struct {
		TrackerByName *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByName, err
}

func AssigneesByOwner(client *gqlclient.Client, ctx context.Context, owner string, tracker string, id int32) (trackerByOwner *Tracker, err error) {
	op := gqlclient.NewOperation("query assigneesByOwner ($owner: String!, $tracker: String!, $id: Int!) {\n\ttrackerByOwner(owner: $owner, tracker: $tracker) {\n\t\tticket(id: $id) {\n\t\t\tassignees {\n\t\t\t\tcanonicalName\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("owner", owner)
	op.Var("tracker", tracker)
	op.Var("id", id)
	var respData struct {
		TrackerByOwner *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByOwner, err
}

func CompleteTicketId(client *gqlclient.Client, ctx context.Context, name string) (trackerByName *Tracker, err error) {
	op := gqlclient.NewOperation("query completeTicketId ($name: String!) {\n\ttrackerByName(name: $name) {\n\t\t... completeTicket\n\t}\n}\nfragment completeTicket on Tracker {\n\ttickets {\n\t\tresults {\n\t\t\tid\n\t\t\tsubject\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	var respData struct {
		TrackerByName *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByName, err
}

func CompleteTicketIdByOwner(client *gqlclient.Client, ctx context.Context, owner string, tracker string) (trackerByOwner *Tracker, err error) {
	op := gqlclient.NewOperation("query completeTicketIdByOwner ($owner: String!, $tracker: String!) {\n\ttrackerByOwner(owner: $owner, tracker: $tracker) {\n\t\t... completeTicket\n\t}\n}\nfragment completeTicket on Tracker {\n\ttickets {\n\t\tresults {\n\t\t\tid\n\t\t\tsubject\n\t\t}\n\t}\n}\n")
	op.Var("owner", owner)
	op.Var("tracker", tracker)
	var respData struct {
		TrackerByOwner *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerByOwner, err
}

func CompleteTicketAssign(client *gqlclient.Client, ctx context.Context, name string, id int32) (me *User, trackerByName *Tracker, err error) {
	op := gqlclient.NewOperation("query completeTicketAssign ($name: String!, $id: Int!) {\n\tme {\n\t\tcanonicalName\n\t}\n\ttrackerByName(name: $name) {\n\t\tticket(id: $id) {\n\t\t\tassignees {\n\t\t\t\tcanonicalName\n\t\t\t}\n\t\t}\n\t\ttickets {\n\t\t\tresults {\n\t\t\t\tassignees {\n\t\t\t\t\tcanonicalName\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("name", name)
	op.Var("id", id)
	var respData struct {
		Me            *User
		TrackerByName *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, respData.TrackerByName, err
}

func CompleteTicketAssignByOwner(client *gqlclient.Client, ctx context.Context, owner string, tracker string, id int32) (me *User, trackerByOwner *Tracker, err error) {
	op := gqlclient.NewOperation("query completeTicketAssignByOwner ($owner: String!, $tracker: String!, $id: Int!) {\n\tme {\n\t\tcanonicalName\n\t}\n\ttrackerByOwner(owner: $owner, tracker: $tracker) {\n\t\tticket(id: $id) {\n\t\t\tassignees {\n\t\t\t\tcanonicalName\n\t\t\t}\n\t\t}\n\t\ttickets {\n\t\t\tresults {\n\t\t\t\tassignees {\n\t\t\t\t\tcanonicalName\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("owner", owner)
	op.Var("tracker", tracker)
	op.Var("id", id)
	var respData struct {
		Me             *User
		TrackerByOwner *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Me, respData.TrackerByOwner, err
}

func TrackerNames(client *gqlclient.Client, ctx context.Context) (trackers *TrackerCursor, err error) {
	op := gqlclient.NewOperation("query trackerNames {\n\ttrackers {\n\t\tresults {\n\t\t\tname\n\t\t}\n\t}\n}\n")
	var respData struct {
		Trackers *TrackerCursor
	}
	err = client.Execute(ctx, op, &respData)
	return respData.Trackers, err
}

func DeleteTracker(client *gqlclient.Client, ctx context.Context, id int32) (deleteTracker *Tracker, err error) {
	op := gqlclient.NewOperation("mutation deleteTracker ($id: Int!) {\n\tdeleteTracker(id: $id) {\n\t\tname\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeleteTracker *Tracker
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeleteTracker, err
}

func SubmitComment(client *gqlclient.Client, ctx context.Context, trackerId int32, ticketId int32, input SubmitCommentInput) (submitComment *Event, err error) {
	op := gqlclient.NewOperation("mutation submitComment ($trackerId: Int!, $ticketId: Int!, $input: SubmitCommentInput!) {\n\tsubmitComment(trackerId: $trackerId, ticketId: $ticketId, input: $input) {\n\t\tticket {\n\t\t\tsubject\n\t\t}\n\t}\n}\n")
	op.Var("trackerId", trackerId)
	op.Var("ticketId", ticketId)
	op.Var("input", input)
	var respData struct {
		SubmitComment *Event
	}
	err = client.Execute(ctx, op, &respData)
	return respData.SubmitComment, err
}

func UpdateTicketStatus(client *gqlclient.Client, ctx context.Context, trackerId int32, ticketId int32, input UpdateStatusInput) (updateTicketStatus *Event, err error) {
	op := gqlclient.NewOperation("mutation updateTicketStatus ($trackerId: Int!, $ticketId: Int!, $input: UpdateStatusInput!) {\n\tupdateTicketStatus(trackerId: $trackerId, ticketId: $ticketId, input: $input) {\n\t\tticket {\n\t\t\tsubject\n\t\t}\n\t}\n}\n")
	op.Var("trackerId", trackerId)
	op.Var("ticketId", ticketId)
	op.Var("input", input)
	var respData struct {
		UpdateTicketStatus *Event
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UpdateTicketStatus, err
}

func DeleteLabel(client *gqlclient.Client, ctx context.Context, id int32) (deleteLabel *Label, err error) {
	op := gqlclient.NewOperation("mutation deleteLabel ($id: Int!) {\n\tdeleteLabel(id: $id) {\n\t\tname\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeleteLabel *Label
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeleteLabel, err
}

func CreateLabel(client *gqlclient.Client, ctx context.Context, trackerId int32, name string, foreground string, background string) (createLabel *Label, err error) {
	op := gqlclient.NewOperation("mutation createLabel ($trackerId: Int!, $name: String!, $foreground: String!, $background: String!) {\n\tcreateLabel(trackerId: $trackerId, name: $name, foreground: $foreground, background: $background) {\n\t\tname\n\t\tbackgroundColor\n\t\tforegroundColor\n\t}\n}\n")
	op.Var("trackerId", trackerId)
	op.Var("name", name)
	op.Var("foreground", foreground)
	op.Var("background", background)
	var respData struct {
		CreateLabel *Label
	}
	err = client.Execute(ctx, op, &respData)
	return respData.CreateLabel, err
}

func DeleteACL(client *gqlclient.Client, ctx context.Context, id int32) (deleteACL *TrackerACL, err error) {
	op := gqlclient.NewOperation("mutation deleteACL ($id: Int!) {\n\tdeleteACL(id: $id) {\n\t\ttracker {\n\t\t\tname\n\t\t}\n\t\tentity {\n\t\t\tcanonicalName\n\t\t}\n\t}\n}\n")
	op.Var("id", id)
	var respData struct {
		DeleteACL *TrackerACL
	}
	err = client.Execute(ctx, op, &respData)
	return respData.DeleteACL, err
}

func TrackerSubscribe(client *gqlclient.Client, ctx context.Context, trackerId int32) (trackerSubscribe *TrackerSubscription, err error) {
	op := gqlclient.NewOperation("mutation trackerSubscribe ($trackerId: Int!) {\n\ttrackerSubscribe(trackerId: $trackerId) {\n\t\ttracker {\n\t\t\tname\n\t\t\towner {\n\t\t\t\tcanonicalName\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("trackerId", trackerId)
	var respData struct {
		TrackerSubscribe *TrackerSubscription
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerSubscribe, err
}

func TrackerUnsubscribe(client *gqlclient.Client, ctx context.Context, trackerId int32) (trackerUnsubscribe *TrackerSubscription, err error) {
	op := gqlclient.NewOperation("mutation trackerUnsubscribe ($trackerId: Int!) {\n\ttrackerUnsubscribe(trackerId: $trackerId, tickets: false) {\n\t\ttracker {\n\t\t\tname\n\t\t\towner {\n\t\t\t\tcanonicalName\n\t\t\t}\n\t\t}\n\t}\n}\n")
	op.Var("trackerId", trackerId)
	var respData struct {
		TrackerUnsubscribe *TrackerSubscription
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TrackerUnsubscribe, err
}

func TicketSubscribe(client *gqlclient.Client, ctx context.Context, trackerId int32, ticketId int32) (ticketSubscribe *TicketSubscription, err error) {
	op := gqlclient.NewOperation("mutation ticketSubscribe ($trackerId: Int!, $ticketId: Int!) {\n\tticketSubscribe(trackerId: $trackerId, ticketId: $ticketId) {\n\t\tticket {\n\t\t\tid\n\t\t}\n\t}\n}\n")
	op.Var("trackerId", trackerId)
	op.Var("ticketId", ticketId)
	var respData struct {
		TicketSubscribe *TicketSubscription
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TicketSubscribe, err
}

func TicketUnsubscribe(client *gqlclient.Client, ctx context.Context, trackerId int32, ticketId int32) (ticketUnsubscribe *TicketSubscription, err error) {
	op := gqlclient.NewOperation("mutation ticketUnsubscribe ($trackerId: Int!, $ticketId: Int!) {\n\tticketUnsubscribe(trackerId: $trackerId, ticketId: $ticketId) {\n\t\tticket {\n\t\t\tid\n\t\t}\n\t}\n}\n")
	op.Var("trackerId", trackerId)
	op.Var("ticketId", ticketId)
	var respData struct {
		TicketUnsubscribe *TicketSubscription
	}
	err = client.Execute(ctx, op, &respData)
	return respData.TicketUnsubscribe, err
}

func AssignUser(client *gqlclient.Client, ctx context.Context, trackerId int32, ticketId int32, userId int32) (assignUser *Event, err error) {
	op := gqlclient.NewOperation("mutation assignUser ($trackerId: Int!, $ticketId: Int!, $userId: Int!) {\n\tassignUser(trackerId: $trackerId, ticketId: $ticketId, userId: $userId) {\n\t\tticket {\n\t\t\tsubject\n\t\t}\n\t}\n}\n")
	op.Var("trackerId", trackerId)
	op.Var("ticketId", ticketId)
	op.Var("userId", userId)
	var respData struct {
		AssignUser *Event
	}
	err = client.Execute(ctx, op, &respData)
	return respData.AssignUser, err
}

func UnassignUser(client *gqlclient.Client, ctx context.Context, trackerId int32, ticketId int32, userId int32) (unassignUser *Event, err error) {
	op := gqlclient.NewOperation("mutation unassignUser ($trackerId: Int!, $ticketId: Int!, $userId: Int!) {\n\tunassignUser(trackerId: $trackerId, ticketId: $ticketId, userId: $userId) {\n\t\tticket {\n\t\t\tsubject\n\t\t}\n\t}\n}\n")
	op.Var("trackerId", trackerId)
	op.Var("ticketId", ticketId)
	op.Var("userId", userId)
	var respData struct {
		UnassignUser *Event
	}
	err = client.Execute(ctx, op, &respData)
	return respData.UnassignUser, err
}
